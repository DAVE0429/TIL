Bearer 토큰
서버에 요청을 보낼 때, HTTP 헤더에 토큰을 포함시켜 인증하는 방식
OAuth 프레임워크에서 엑세스 토큰으로 사용하는 토큰의 유형
불투명한 (Opaque) 문자열일 수도 있고, JSON Web Token(JWT)일 수 있다.
Bearer 토큰은 일반적으로 인증 서버에 의해 생성되어 클라이언트에 전달된다. 클라이언트는 보호된 자원에 접근하기 위해 요청할 때 HTTP 인증 헤더에 토큰을 포함시킨다.
JWT와 달리 Bearer 토큰은 표준화된 구조가 없다. 클라이언트에게는 불투명하며, 클라이언트는 이를 디코드하거나 해석하려고 시도해서는 안 된다.

Bearer 인증의 장점 및 단점
안전하고 확장이 쉽다, Bearer 토큰은 쉽게 복호화 할 수 없고 OAuth는 프레임 워크의 인증 및 리소스 서버는 SSL/TLS를 필수로 사용한다.
Bearer 토큰 자체가 메타데이터를 가지고 있어서 서버는 토큰을 발급만 하고 보관할 필요가 없다.
Bearer 토큰이 외부에 노출되면 다른 서비스도 토큰으로 바로 리소스를 접근할 수 있다.

JWT(Json Web Token)
헤더: 토큰에 대한 메타데이터를 포함하며, 토큰의 유형과 서명에 사용되는 알고리즘을 담고 있다.
페이로드: 주장(claims)을 포함합니다. 주장은 실체(일반적으로 사용자)에 대한 진술 및 추가 데이터를 포함한다.
서명: 이는 JWT의 발신자가 주장하는 대로인지를 검증하고 메시지가 중간에 변경되지 않았음을 보장하는 데 사용된다.
클라이언트(사용자)가 시스템에 로그인을 하면 서버는 사용자의 ID와 비밀번호를 검증합니다. 유효한 경우, 서버는 사용자 정보를 담은 JWT를 생성하여 클라이언트에게 반환합니다. 이후 클라이언트는 이 JWT를 HTTP 요청 헤더에 포함시켜 서버에 전송하고, 서버는 이를 검증하여 사용자를 인증합니다.
세 부분을 각각 Base64URL로 인코딩되며 점(.)으로 이어 붙인 하나의 문자열로 구성됩니다.

로그인 요청: 클라이언트는 사용자 이름과 비밀번호를 서버에 전송하여 로그인 요청을 합니다.
토큰 생성: 서버는 사용자 정보를 확인하고, 유효한 경우 JWT를 생성합니다. 이 JWT는 사용자 ID, 이름, 권한 등의 정보를 포함하고 있습니다.
토큰 반환: 서버는 생성된 JWT를 클라이언트에게 반환합니다.
토큰 저장: 클라이언트는 받은 JWT를 저장합니다.
인증 요청: 클라이언트는 이후 서버에 요청을 보낼 때, HTTP 요청 헤더에 JWT를 포함시켜 보냅니다.
토큰 검증: 서버는 요청을 받을 때 JWT를 확인합니다. 헤더와 페이로드를 디코딩하고, 서명을 검증하여 토큰이 유효한지 확인합니다.
인증 결과: 토큰이 유효하면 서버는 요청을 처리하고, 그렇지 않으면 인증 오류를 반환합니다.

크로스 오리진 리소스 공유는 어떻게 작동하나요?
표준 인터넷 통신에서 브라우저는 애플리케이션 서버에 HTTP 요청을 보내고 HTTP 응답으로 데이터를 수신하여 표시합니다. 브라우저 용어에서는 현재 브라우저 URL을 현재 오리진이라고 하고 서드 파티 URL을 크로스 오리진이라고 합니다.

크로스 오리진 요청을 할 때 요청-응답 프로세스는 다음과 같습니다.

브라우저는 현재 오리진의 프로토콜, 호스트 및 포트에 대한 정보가 포함된 오리진 헤더를 요청에 추가합니다.
서버는 현재 오리진 헤더를 확인하고 요청된 데이터와 Access-Control-Allow-Origin(허용되는 출처에 대한 접근 제어) 헤더로 응답합니다.
브라우저는 액세스 제어 요청 헤더를 확인한 후 반환된 데이터를 클라이언트 애플리케이션과 공유합니다.
서버에서 크로스 오리진 액세스를 허용하지 않는 경우에는 오류 메시지로 응답합니다.

교차출처 리소스 공유
프로토콜, 도메인, 포트 이 세개 중 하나라도 다르면 cors에러를 만날 수 있다.
예전에는 프론트엔드와 백엔드르 따로 구성하지 않고 한번에 구성했기 떄문에 모든 처리가 하나의 도메인에서 가능했다.
하지만 클라이언트가 API를 직접 호출하는 형식이 많아 지다보니 CORS 정책이 생겼다.

'Access-Control-Allow-Origin': <origin> | *
*를 설정하면 출처에 상관없이 리소스에 접근할 수 있는 와일드카드이기 때문에 보안에 취약해져요. 그래서 'Access-Control-Allow-Origin': https://myshop.com과 같이 직접 허용할 출처를 세팅하는 방법이 더 좋습니다.

이 문제를 해결하려면, 웹 애플리케이션이 직접 http://api.example.com에 API 요청하는 대신, 같은 출처(http://example.com)에 위치한 프락시 서버를 통해 API 요청을 중계하도록 구성하면 됩니다.

웹 애플리케이션 → http://example.com/api/proxy → (서버 내부 요청) → http://api.example.com

출처가 다른 서버간의 리소스 공유
CORS는 한 도메인에서 로드되어 다른 도메인에 있는 리소스와 상호 작용하는 클라이언트 웹 애플리케이션에 대한 방법을 정의합니다. CORS는 복잡한 애플리케이션의 경우 클라이언트 측 코드에서 서드 파티 API 및 리소스를 참조하는 경우가 많기 때문에 유용합니다. 예를 들어 브라우저를 사용하여 동영상 플랫폼 API에서 동영상을 가져오거나, 공용 글꼴 라이브러리의 글꼴을 사용하거나, 국가 날씨 데이터베이스의 날씨 데이터를 표시하는 애플리케이션이 여기에 포함됩니다. CORS를 사용하면 클라이언트 브라우저에서 데이터를 전송하기 전에 서드 파티 서버를 확인하여 요청 승인 여부를 확인할 수 있습니다.


principal: 아이디 (username)
credential: 비밀번호(password)
유저는 인증 정보가 필요하고 관리자는 해당 정보를 참고해서 권한을 인가한다.


1. Http Request 수신 
-> 사용자가 로그인 정보와 함께 인증 요청을 한다.

2. 유저 자격을 기반으로 인증토큰 생성 
-> AuthenticationFilter가 요청을 가로채고, 가로챈 정보를 통해 UsernamePasswordAuthenticationToken의 인증용 객체를 생성한다.

3. FIlter를 통해 AuthenticationToken을 AuthenticationManager로 위임
-> AuthenticationManager의 구현체인 ProviderManager에게 생성한 UsernamePasswordToken 객체를 전달한다.

4. AuthenticationProvider의 목록으로 인증을 시도
-> AutenticationManger는 등록된 AuthenticationProvider들을 조회하며 인증을 요구한다.

5. UserDetailsService의 요구
-> 실제 데이터베이스에서 사용자 인증정보를 가져오는 UserDetailsService에 사용자 정보를 넘겨준다.

6. UserDetails를 이용해 User객체에 대한 정보 탐색
-> 넘겨받은 사용자 정보를 통해 데이터베이스에서 찾아낸 사용자 정보인 UserDetails 객체를 만든다.

7. User 객체의 정보들을 UserDetails가 UserDetailsService(LoginService)로 전달
-> AuthenticaitonProvider들은 UserDetails를 넘겨받고 사용자 정보를 비교한다.

8. 인증 객체 or AuthenticationException
-> 인증이 완료가되면 권한 등의 사용자 정보를 담은 Authentication 객체를 반환한다.

9. 인증 끝
-> 다시 최초의 AuthenticationFilter에 Authentication 객체가 반환된다.

10. SecurityContext에 인증 객체를 설정
-> Authentication 객체를 Security Context에 저장한다.
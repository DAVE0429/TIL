### @MappedSuperclass란
- @MappedSuperclass는 JPA에서 엔티티 클래스들 간에 공통된 매핑 정보를 재사용하기 위한 어노테이션입니다. 
  이 어노테이션을 사용하면 여러 엔티티 클래스에서 동일한 매핑 정보를 공유하여 코드의 중복을 줄여줍니다. 
  가령 createdAt, updatedAt 등 모든 엔티티에 공통적으로 포함되는 필드가 있다면 @MappedSuperclass를 이용하여 공통된 필드를 포함하는 클래스를 다른 엔티티들이 상속받도록 하면 됩니다.

- 주의할 점
  기본적으로 MappedSuperclass로 지정된 클래스는 테이블로 매핑되지 않습니다. 
  즉, MappedSuperclass로 지정된 클래스는 엔티티가 아닙니다.
  대신, 이 클래스의 필드와 매핑 정보는 하위 엔티티 클래스에 상속됩니다.
  그렇기 때문에 MappedSuperclass로 지정된 클래스는 추상 클래스로 정의하는 것이 좋습니다.

1. VO (Value Object):
  VO는 값을 담는 객체를 나타냅니다. 주로 데이터베이스의 테이블에 대응되는 엔티티의 상태를 나타냅니다.
  VO는 주로 불변(Immutable)하고, equals() 및 hashCode()와 같은 메서드를 오버라이드하여 객체의 동등성을 비교하는 데 사용됩니다.


2. BO (Business Object):
  BO는 비즈니스 로직을 처리하는 객체를 나타냅니다. 주로 비즈니스 규칙을 구현하고, 데이터를 처리하며, 다양한 계산을 수행하는 데 사용됩니다.
  BO는 비즈니스 도메인에서의 객체를 나타내며, 비즈니스 규칙을 캡슐화하고 적용하는 데 사용됩니다.


3. DAO (Data Access Object):
  DAO는 데이터베이스와의 상호 작용을 담당하는 객체를 나타냅니다. 주로 데이터베이스에 접근하여 데이터를 검색, 삽입, 갱신, 삭제하는 데 사용됩니다.  
  DAO는 비즈니스 계층과 데이터 액세스 계층 간의 인터페이스를 제공하여, 비즈니스 로직이 데이터베이스에 직접 접근하지 않고도 데이터에 접근할 수 있도록 합니다.


4. DTO (Data Transfer Object):
  DTO는 데이터 전송을 위한 객체를 나타냅니다. 주로 여러 계층 간에 데이터를 전달하고 전송하기 위해 사용됩니다.
  DTO는 데이터를 보유하는 역할로, 특히 원격 인터페이스(예: 웹 서비스)를 통해 데이터를 전송할 때 사용됩니다. 비즈니스 로직을 포함하지 않으며, 단순히 데이터의 전달 목적으로 사용됩니다.

### 엔티티와 DTO를 구분하여 사용하는 이유.
1. 레이어 간의 분리: Entity는 주로 데이터베이스와 관련된 비즈니스 로직을 포함하는데 반해, DTO는 클라이언트와의 통신을 위한 데이터 전송 객체입니다. 이는 레이어 간의 역할 분리를 촉진하고, 각각의 역할에 맞는 책임을 부여하여 시스템을 더 깔끔하고 확장 가능하게 만듭니다.

2. 불필요한 정보 노출 방지: Entity는 데이터베이스 스키마에 직접적으로 매핑되어 있기 때문에, 필요하지 않은 속성이나 민감한 정보가 클라이언트로 전달될 수 있습니다. DTO를 사용하면 클라이언트가 필요로 하는 정보만을 선택적으로 전송할 수 있으며, 보안과 프라이버시를 보다 쉽게 관리할 수 있습니다.

3. 네트워크 트래픽 감소: Entity는 종종 연관된 엔티티를 로드하는 데 지연될 수 있는 연관된 객체 그래프를 가지고 있습니다. 이러한 경우, 클라이언트에 필요한 데이터만 포함된 DTO를 사용하면 네트워크 트래픽을 줄일 수 있습니다. 특히 모바일 애플리케이션과 같이 대역폭이 제한된 환경에서는 이러한 최적화가 더욱 중요합니다.

4. API 버전 관리: Entity는 시스템의 핵심 데이터 구조를 나타내기 때문에 변경될 가능성이 높습니다. 이에 반해 DTO는 API의 인터페이스로 사용되기 때문에 API 버전 관리에 용이합니다. 새로운 버전의 API를 도입할 때 기존의 Entity를 변경하지 않고 DTO를 조정함으로써 버전 관리를 보다 유연하게 할 수 있습니다.

5. 클라이언트 종속성 감소: Entity는 데이터베이스와 강하게 결합되어 있기 때문에, 클라이언트 코드가 데이터베이스 스키마에 직접적으로 의존하게 됩니다. 이는 클라이언트 코드의 유지 보수와 변경을 어렵게 만들 수 있습니다. DTO를 사용하면 클라이언트가 독립적으로 동작할 수 있도록 하여 종속성을 최소화할 수 있습니다.
